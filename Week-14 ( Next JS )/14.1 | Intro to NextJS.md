# 14.1 | Intro to NextJS

### **Next.js Introduction**

Next.js is a popular open-source React framework that enables developers to build server-rendered React applications and static websites with ease. It was created by **Vercel** to address some challenges that React developers often face. Next.js enhances React by providing essential features for modern web development, such as **server-side rendering (SSR)**, **static site generation (SSG)**, and **API routes**.

---

### **Why Next.js?**

Next.js solves several issues that are commonly encountered in React applications, including:

1. **Backend Integration**:
   - In React, developers need to set up a separate backend project (e.g., with Node.js, Express) to handle API routes.
   - Next.js eliminates this need by providing **built-in API routes** where backend logic can coexist with frontend code.

2. **Routing**:
   - React does not have built-in routing; developers need to use libraries like `react-router-dom`.
   - Next.js provides a **file-based routing system** out of the box. Any file created in the `pages` directory automatically becomes a route.

3. **SEO Optimization**:
   - Traditional React applications are not inherently optimized for Search Engine Optimization (SEO) because they rely heavily on client-side rendering.
   - Next.js supports **server-side rendering (SSR)** and **static site generation (SSG)**, making it more SEO-friendly by providing pre-rendered HTML to search engine crawlers.

4. **Performance Issues**:
   - React can suffer from a "waterfalling problem," where data fetching occurs in multiple stages, delaying the rendering process.
   - Next.js supports **data fetching strategies** like `getServerSideProps` and `getStaticProps` to fetch data efficiently and render pages quickly.

5. **React Server Components**:
   - While React has introduced **Server Components** to improve rendering and performance, Next.js integrates these features seamlessly into its ecosystem, providing a better developer experience.

---

### **Key Features of Next.js**

1. **Server-Side Rendering (SSR)**:
   - Renders HTML on the server for each request, ensuring faster initial page loads and better SEO.

2. **Static Site Generation (SSG)**:
   - Pre-generates HTML at build time, delivering ultra-fast performance for static content.

3. **API Routes**:
   - Developers can define API endpoints directly in the `pages/api` directory, eliminating the need for a separate backend project.

4. **File-Based Routing**:
   - The folder and file structure in the `pages` directory maps directly to application routes (e.g., `pages/about.js` maps to `/about`).

5. **Incremental Static Regeneration (ISR)**:
   - Updates static content dynamically without requiring a full rebuild, making it ideal for content-driven websites.

6. **Built-In CSS and Sass Support**:
   - Allows importing CSS and Sass files directly into components for styling.

7. **Image Optimization**:
   - Provides built-in support for optimizing images using the `<Image>` component.

8. **Middleware**:
   - Enables developers to execute custom code before requests are completed, useful for authentication, redirection, etc.

9. **Automatic Code Splitting**:
   - Loads only the JavaScript code necessary for the current page, reducing initial load time.

---

### **Prerequisites for Learning Next.js**

1. **Basic Frontend Knowledge**:
   - Understanding HTML, CSS, and JavaScript is essential.
   - Familiarity with ES6+ features like modules, arrow functions, and destructuring is helpful.

2. **React Knowledge**:
   - You should know how to:
     - Create components
     - Use React state and props
     - Work with lifecycle methods or hooks (e.g., `useState`, `useEffect`)
     - Implement basic routing (e.g., `react-router-dom`)

3. **Basic Node.js** (Optional but helpful):
   - A foundational understanding of Node.js will be useful, especially for working with API routes and server-side rendering.

---

### **Addressing the "Waterfalling Problem"**

In traditional React applications, **waterfalling** occurs when data fetching depends on multiple sequential requests. For instance:

1. Fetch user data.
2. Fetch posts related to the user.
3. Fetch comments for each post.

Each step waits for the previous one to complete, leading to delayed rendering.

Next.js minimizes this issue by:
- Allowing **data fetching at the page level** (`getStaticProps` or `getServerSideProps`) to fetch all necessary data upfront.
- Utilizing **React Server Components** for partial hydration, enabling faster data fetching and rendering.

---

### **Conclusion**

Next.js is a powerful extension of React that simplifies development by handling common issues like routing, backend integration, and SEO. It is an excellent choice for modern web applications, providing performance optimization and scalability.

### **SEO Optimization with Next.js**
![World Map](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F085e8ad8-528e-47d7-8922-a23dc4016453%2Fe7961f82-9447-4df5-a4e0-ce73dad86ffa%2FScreenshot_2024-03-02_at_10.06.37_AM.png?table=block&id=f018e860-6c2d-4435-91ec-b7e2727313b3&cache=v2)
#### **Understanding SEO Challenges in React**
React, as a JavaScript library, primarily relies on client-side rendering (CSR). This means that when a page is loaded, the browser first receives an almost empty `index.html` file with links to JavaScript files. The JavaScript is then executed to populate the DOM dynamically.

Here’s the issue:
- **Googlebot's behavior**: While Googlebot has become more advanced and can execute JavaScript, its capabilities are still not perfect. Many search engine crawlers (especially Bing, Yahoo, or smaller ones) may not run JavaScript at all.
- **Result for React websites**: When a crawler visits a React site, it often gets back an empty or minimal HTML document like this:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>React App</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="/main.js"></script>
  </body>
</html>
```
![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F085e8ad8-528e-47d7-8922-a23dc4016453%2F08ec429f-27b6-4518-8b4b-7c84d00151a8%2FScreenshot_2024-03-02_at_10.10.10_AM.png?table=block&id=a5c7d6ff-b0b5-4551-8cee-996f13715004&cache=v2)
- **SEO Impact**: Since the page content is dynamically rendered after JavaScript execution, the crawlers don’t "see" the actual content of the page. This makes it harder for the bot to understand what the page is about, reducing its ranking on search engines.

---

#### **How Next.js Addresses SEO Challenges**

Next.js introduces **Server-Side Rendering (SSR)** and **Static Site Generation (SSG)**, which serve fully-rendered HTML to search engine crawlers, eliminating the issues with JavaScript execution. Here's how:

1. **Pre-rendering Pages**:
   - **Static Site Generation (SSG)**:
     - HTML is generated at **build time**.
     - Ideal for pages where content doesn’t change often (e.g., blogs, landing pages).
     - Example:
       ```js
       export async function getStaticProps() {
         const data = await fetch('https://api.example.com/data');
         return { props: { data } };
       }
       ```
       This approach ensures that the crawler gets a fully-rendered HTML file.

   - **Server-Side Rendering (SSR)**:
     - HTML is generated **on every request** on the server.
     - Suitable for pages with dynamic data that changes frequently.
     - Example:
       ```js
       export async function getServerSideProps(context) {
         const data = await fetch('https://api.example.com/data');
         return { props: { data } };
       }
       ```

   - **Outcome**: Crawlers receive complete, content-rich HTML, which improves indexing and SEO rankings.

2. **Dynamic Meta Tags**:
   - Next.js supports the `<Head>` component to customize meta tags for each page.
   - Example:
     ```jsx
     import Head from 'next/head';

     const Page = () => (
       <>
         <Head>
           <title>SEO Optimized Page</title>
           <meta name="description" content="This is an SEO-optimized page using Next.js." />
         </Head>
         <h1>Welcome to my page!</h1>
       </>
     );
     ```

3. **Improved Performance**:
   - Faster loading times contribute to better SEO. Next.js optimizes performance with:
     - **Automatic Code Splitting**: Only the JavaScript required for the current page is loaded.
     - **Image Optimization**: Automatically resizes and serves images in the appropriate format.
![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F085e8ad8-528e-47d7-8922-a23dc4016453%2F58e004c5-0d4e-44f6-9a3b-7042ae5b979a%2FScreenshot_2024-03-02_at_10.42.47_AM.png?table=block&id=4848f05f-bf56-489c-8cbd-567b18af65dc&cache=v2)
4. **Canonical Tags and Sitemap Generation**:
   - Canonical tags help avoid duplicate content issues, and Next.js allows easy integration of sitemap generation tools.

---

#### **How Search Engines Handle React vs. Next.js**

- **React**:
  When Googlebot visits a React-based website, it initially sees an almost empty HTML response. While Googlebot may eventually render the JavaScript and see the content, this process is resource-intensive and often results in delayed or incomplete indexing.
![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F085e8ad8-528e-47d7-8922-a23dc4016453%2F63cda89d-8385-4dd8-932a-4c5c474e9220%2FScreenshot_2024-03-02_at_11.25.40_AM.png?table=block&id=660dd700-22c4-42d8-bd63-18ae70aa3b1a&cache=v2)
- **Next.js**:
  When Googlebot visits a Next.js-based website:
  - For **SSG**: It receives fully pre-rendered static HTML files.
  - For **SSR**: It receives HTML generated on the server for each request.
![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F085e8ad8-528e-47d7-8922-a23dc4016453%2F06ef92dd-6676-4b50-bd2c-3f24e5537191%2FScreenshot_2024-03-02_at_11.55.58_AM.png?table=block&id=489dbf7b-618a-46e7-892d-54bc6d9fca73&cache=v2)
This ensures that search engines immediately "see" the complete content, which improves indexing and rankings.

---

#### **Next.js Workflow Example for SEO**

1. **Static Site Generation Example**:
   Suppose you're building a blog. Using SSG, Next.js can pre-render each blog post as static HTML during build time:
   ```js
   export async function getStaticPaths() {
     const posts = await fetch('https://api.example.com/posts');
     const paths = posts.map(post => ({
       params: { id: post.id },
     }));

     return { paths, fallback: false };
   }

   export async function getStaticProps({ params }) {
     const post = await fetch(`https://api.example.com/posts/${params.id}`);
     return { props: { post } };
   }
   ```

2. **Server-Side Rendering Example**:
   For a dynamic dashboard with frequently changing data:
   ```js
   export async function getServerSideProps() {
     const data = await fetch('https://api.example.com/dashboard');
     return { props: { data } };
   }
   ```

---

#### **Conclusion**

Next.js enhances React applications by resolving major SEO issues. By providing **pre-rendered HTML** through SSG or SSR, it ensures that search engine crawlers can efficiently index pages. This, combined with its support for dynamic meta tags and performance optimizations, makes Next.js an excellent choice for building SEO-friendly websites.

### **The Waterfalling Problem in React**

In React, the **waterfalling problem** occurs when data fetching operations are performed sequentially (one dependent on the completion of the previous), leading to slower page loading times. Here’s an example request cycle for a React blogging website:

1. **Fetch the `index.html` from the CDN**:
   - The browser retrieves the main `index.html` file.
2. **Fetch `script.js` from the CDN**:
   - The browser downloads the bundled JavaScript file containing the app logic.
3. **Check if the user is logged in**:
   - The app fetches authentication status from an API, then redirects the user if needed.
4. **Fetch the actual blog content**:
   - After the login check, the app fetches blog data from another API.

Each of these steps happens **sequentially**, delaying when the page becomes fully interactive. This is particularly problematic for users with slow network connections or on high-latency devices.

---

### **How Next.js Solves the Waterfalling Problem**

Next.js addresses the waterfalling problem by providing **data fetching mechanisms** that enable parallel and efficient loading of data:

#### **1. Server-Side Rendering (SSR)**
- With SSR, data fetching and HTML generation happen **on the server** before the page is sent to the browser. This reduces round trips and sends a fully rendered page to the client on the first request.
- Example:
  ```js
  export async function getServerSideProps(context) {
    const user = await fetch('https://api.example.com/user');
    const blogs = await fetch('https://api.example.com/blogs');
    
    return { props: { user, blogs } }; // Both are fetched in parallel
  }
  ```
- **Benefit**: Multiple data fetching operations are handled on the server in parallel, reducing delays caused by sequential client-side fetches.

---

#### **2. Static Site Generation (SSG)**
- Pages are pre-rendered at **build time**. This eliminates the need to fetch content on the client side, as the HTML is already generated and served directly from the CDN.
- Example:
  ```js
  export async function getStaticProps() {
    const blogs = await fetch('https://api.example.com/blogs');
    
    return { props: { blogs } };
  }
  ```
- **Benefit**: Blog content is fetched and embedded into the HTML during build time, making the page load instantly without further API calls.

---

#### **3. Incremental Static Regeneration (ISR)**
- ISR allows pre-rendered pages to be updated **on demand**, without rebuilding the entire site. This is particularly useful for pages that need periodic updates (like blogs).
- Example:
  ```js
  export async function getStaticProps() {
    const blogs = await fetch('https://api.example.com/blogs');
    
    return {
      props: { blogs },
      revalidate: 60, // Revalidate every 60 seconds
    };
  }
  ```
- **Benefit**: Pages are served as static content but updated periodically, ensuring users get fresh data without additional round trips.

---

#### **4. Combined Data Fetching Strategies**
Next.js allows combining **client-side rendering (CSR)** with **SSR** or **SSG** for dynamic use cases:
- Example:
  - The initial page is pre-rendered with SSR or SSG.
  - Additional data (e.g., user-specific content) is fetched **client-side** after the page is loaded.

---

#### **5. Parallel Data Fetching**
- Instead of fetching data sequentially, Next.js allows fetching data in parallel using functions like `getStaticProps` and `getServerSideProps`. This minimizes latency and improves performance.

---

#### **Example Comparison**

**React (Traditional CSR with Waterfalling):**
```jsx
useEffect(() => {
  fetch('/api/check-login').then(() => {
    fetch('/api/blogs').then(setBlogs);
  });
}, []);
```
- **Problem**: Sequential fetching delays the loading of blogs until login status is confirmed.

**Next.js (SSR or SSG):**
```js
export async function getServerSideProps() {
  const [user, blogs] = await Promise.all([
    fetch('https://api.example.com/user'),
    fetch('https://api.example.com/blogs'),
  ]);
  
  return { props: { user, blogs } };
}
```
- **Benefit**: Both APIs are fetched in parallel on the server, and the fully rendered page is sent to the browser in one step.

---

### **Key Benefits of Next.js**

1. **Pre-rendered Pages**:
   - Eliminates client-side waterfalling by pre-fetching data either at build time (SSG) or on the server (SSR).

2. **Reduced Round Trips**:
   - Sends a fully-rendered HTML page to the browser, reducing the need for multiple client-side API calls.

3. **Parallel Data Fetching**:
   - Fetches multiple data sources simultaneously to avoid sequential delays.

4. **SEO Improvements**:
   - Fully-rendered content is delivered to search engine crawlers, ensuring better indexing.

5. **Improved User Experience**:
   - Pages load faster and become interactive sooner, even for dynamic content.

---

### **Conclusion**
Next.js effectively solves the waterfalling problem by shifting data fetching to the server and enabling parallel operations. It ensures faster page loads, better SEO, and an overall smoother user experience compared to traditional React setups.

### **Next.js Offerings Over React**

Next.js is a powerful React framework that enhances the development experience by providing built-in features that address common challenges faced when building React applications. Here are the key advantages of using Next.js over plain React:

---

#### **1. Server-Side Rendering (SSR) - Solves SEO Problems**

- **Explanation**: Next.js supports Server-Side Rendering out of the box. This means that the initial HTML is generated on the server for each request, rather than in the browser after JavaScript loads.
- **Benefit**: SSR improves SEO because search engine crawlers receive fully rendered HTML content, making it easier for them to index pages correctly. This addresses the limitation of client-side rendering in React, where content is rendered after JavaScript execution, potentially causing SEO issues.
- **Additional Note**: Next.js also supports Static Site Generation (SSG) and Incremental Static Regeneration (ISR), providing flexibility in how pages are rendered and updated.

---

#### **2. API Routes - Single Codebase for Frontend and Backend**

- **Explanation**: Next.js allows you to create backend API endpoints directly within your application under the `/pages/api` directory.
- **Benefit**: This feature enables you to have both your frontend and backend code in a single project. It simplifies development and deployment, as you don't need to set up and maintain a separate backend server for handling API requests.
- **Use Cases**:
  - Handling form submissions.
  - Creating custom authentication flows.
  - Interacting with databases or external APIs.

---

#### **3. File-Based Routing (No Need for `react-router-dom`)**

- **Explanation**: Next.js uses a file-system-based routing mechanism. Each page is a React component stored in the `/pages` directory, and the file structure maps directly to the URL structure.
- **Benefit**:
  - **Simplifies Routing**: Eliminates the need for a separate routing library like `react-router-dom`.
  - **Nested Routes**: Easily create nested routes by organizing files into folders.
  - **Dynamic Routes**: Supports dynamic route segments using brackets (e.g., `[id].js`).

---

#### **4. Bundle Size Optimizations and Static Site Generation**

- **Explanation**:
  - **Automatic Code Splitting**: Next.js automatically splits your JavaScript bundles, ensuring that each page only loads the necessary code.
  - **Static Site Generation (SSG)**: Pre-renders pages at build time, generating static HTML files.
- **Benefit**:
  - **Performance**: Reduces the amount of code sent to the client, leading to faster load times.
  - **Scalability**: Static files can be served over a Content Delivery Network (CDN), handling high traffic with ease.
  - **User Experience**: Improves initial page load speed and reduces time-to-interactive.

---

#### **5. Maintained by the Vercel Team**

- **Explanation**: Next.js is developed and maintained by [Vercel](https://vercel.com/), a company specializing in frontend development tools and deployment solutions.
- **Benefit**:
  - **Regular Updates**: Continuous improvements, new features, and optimizations.
  - **Community Support**: A large and active community provides plugins, tutorials, and support.
  - **Integration with Vercel Platform**: Seamless deployment and hosting options optimized for Next.js applications.

---

### **Downsides of Using Next.js**

While Next.js offers numerous advantages, it's important to consider some potential downsides:

---

#### **1. Requirement for a Server for SSR**

- **Explanation**: For Server-Side Rendering and API routes, Next.js requires a Node.js environment to run server-side code.
- **Impact**:
  - **Deployment Complexity**: Deploying SSR applications can be more complex compared to static sites, as you need a server or serverless functions to handle requests.
  - **Cost Considerations**: Hosting an SSR application might be more expensive than a static site due to server resource requirements.
- **Clarification**:
  - **Static Site Generation**: Next.js supports SSG and can export static HTML files (`next export`), which **can** be distributed via a CDN without needing a server.
  - **Serverless Deployment**: Platforms like Vercel and Netlify support serverless functions, allowing SSR and API routes without managing your own servers.

---

#### **2. Opinionated Structure and Potential Lock-In**

- **Explanation**: Next.js enforces certain conventions for file structure, routing, and data fetching methods (`getStaticProps`, `getServerSideProps`).
- **Impact**:
  - **Learning Curve**: Developers need to learn Next.js-specific patterns and lifecycle methods.
  - **Flexibility Constraints**: The opinionated nature might limit customization for unconventional requirements.
  - **Migration Challenges**: Moving away from Next.js to another framework or to plain React can be challenging due to reliance on Next.js-specific features.

---

#### **3. Complexity for Simple Projects**

- **Explanation**: For small or simple applications, Next.js might introduce unnecessary complexity.
- **Impact**:
  - **Overhead**: The additional features of Next.js might be overkill for straightforward projects that don't require SSR or advanced routing.
  - **Bundle Size**: The framework adds to the initial project size compared to plain React.

---

### **Additional Considerations**

---

#### **Deployment Options**

- **Static Export**:
  - Use `next export` to generate a static version of your site.
  - **Benefit**: Can be hosted on any static hosting service or CDN, removing the need for a server.

- **Serverless Functions**:
  - Deploy on platforms that support serverless functions (e.g., Vercel, AWS Lambda).
  - **Benefit**: Handle SSR and API routes without maintaining your own server infrastructure.

- **Traditional Server Deployment**:
  - Deploy your Next.js app on a Node.js server.
  - **Benefit**: Full control over the server environment.

---

#### **Flexibility vs. Convention**

- **Pros of Being Opinionated**:
  - **Consistency**: Encourages best practices and consistent project structures.
  - **Productivity**: Reduces decision fatigue, allowing developers to focus on building features.
- **Cons**:
  - **Limitations**: May not accommodate all use cases, particularly those requiring custom configurations.
  - **Dependency**: Reliance on the framework's conventions can make it harder to switch to a different setup later.

---

#### **Community and Ecosystem**

- **Plugins and Extensions**:
  - Rich ecosystem with plugins for styling, state management, and more.
- **Learning Resources**:
  - Extensive documentation, tutorials, and community support.
- **Third-Party Integrations**:
  - Easy integration with analytics, CMS systems, and authentication services.

---

### **Conclusion**

Next.js enhances React by providing solutions to common challenges such as SEO optimization, routing, and performance. Its built-in features like Server-Side Rendering, API routes, and file-based routing streamline development and can significantly improve the user experience.

However, it's important to weigh these benefits against potential downsides:

- **Server Requirements**: While Next.js can generate static sites suitable for CDN deployment, leveraging SSR and API routes requires server-side execution.
- **Opinionated Nature**: The conventions and structures enforced by Next.js may not suit every project, and migrating away from Next.js can be complex.

**Decision Factors**:

- **Use Next.js if**:
  - SEO is a critical concern.
  - You prefer an integrated solution for routing and API handling.
  - You want performance optimizations out of the box.
  - You're building a complex application that can benefit from SSR or SSG.

- **Consider Plain React if**:
  - You're building a simple application or widget.
  - You require maximum flexibility and control over your setup.
  - You prefer to configure tools and libraries individually.

---

Ultimately, choosing between Next.js and plain React depends on the specific needs and constraints of your project. Next.js offers a robust set of features that can accelerate development and enhance performance but comes with considerations regarding complexity and flexibility.


### **Bootstrapping a Simple Next.js App with Tailwind CSS**

In this guide, we'll walk through the steps to create a basic Next.js application integrated with Tailwind CSS. We'll also explain the purpose of key configuration files and clean up the initial setup to start with a minimal template.

---

#### **Prerequisites**

- **Node.js**: Ensure you have Node.js installed (version 14.0 or higher is recommended).
- **Package Manager**: `npm` comes with Node.js, or you can use `yarn` if preferred.

![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F085e8ad8-528e-47d7-8922-a23dc4016453%2Fd6a3439f-9ff8-456f-90bc-17501c0d46ba%2FScreenshot_2024-03-02_at_1.16.31_PM.png?table=block&id=5d438a5b-1c70-44a2-a409-aad9e9fa8009&cache=v2)

### **Step 1: Create a New Next.js Project**

Use the `create-next-app` command to bootstrap a new Next.js application.

```bash
npx create-next-app@latest my-next-app
```

- **Replace** `my-next-app` with your desired project name.
- **Options**: During setup, you can opt-in for TypeScript support and other features as prompted.

---

### **Step 2: Navigate to Your Project Directory**

```bash
cd my-next-app
```

---

### **Step 3: Install Tailwind CSS**

We'll install Tailwind CSS and its peer dependencies.

```bash
npm install tailwindcss postcss autoprefixer
```

Initialize Tailwind by generating the configuration files.

```bash
npx tailwindcss init -p
```

This creates:

- **`tailwind.config.js`**: Tailwind CSS configuration file.
- **`postcss.config.js`**: PostCSS configuration file.

---

### **Step 4: Configure `tailwind.config.js`**

Update the `tailwind.config.js` file to specify the paths to all of your pages and components.

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{js,ts,jsx,tsx}", // Include all files in the 'app' directory
    "./components/**/*.{js,ts,jsx,tsx}", // Include all files in the 'components' directory if you have one
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

---

### **Step 5: Add Tailwind Directives to `globals.css`**

Locate the `globals.css` file in `app/globals.css` (or `styles/globals.css` depending on your Next.js version). Replace its content with Tailwind's base styles.

```css
/* app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* You can add custom global styles below */
```

---

### **Step 6: Clean Up the Initial Setup**

#### **a. Remove Default Content from `app/page.tsx`**

- **File Location**: `app/page.tsx` (for TypeScript projects) or `app/page.js` (for JavaScript projects).
- **Action**: Delete all the existing content within the component and return an empty `<div>`.

**Before:**

```tsx
// app/page.tsx

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      {/* Default content and components */}
    </main>
  );
}
```

**After:**

```tsx
// app/page.tsx

export default function Home() {
  return <div></div>;
}
```

#### **b. Clean Up `globals.css`**

- **Action**: Remove any default CSS styles provided by Next.js, but **keep the Tailwind directives** (`@tailwind base;`, `@tailwind components;`, `@tailwind utilities;`).

**Before:**

```css
/* app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen;
  /* ... other default styles ... */
}

/* ... other default styles ... */
```

**After:**

```css
/* app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* You can add custom global styles here if needed */
```

---

### **Understanding Key Configuration Files**

#### **1. `next.config.mjs`**

- **Purpose**: This is the Next.js configuration file where you can customize various settings of your Next.js application.
- **Common Configurations**:
  - Enabling experimental features.
  - Customizing webpack configuration.
  - Setting environment variables.
- **Example**:

  ```js
  // next.config.mjs

  const nextConfig = {
    reactStrictMode: true,
    swcMinify: true,
    // Additional configurations...
  };

  export default nextConfig;
  ```

#### **2. `tailwind.config.js`**

- **Purpose**: Tailwind CSS configuration file where you can customize the default Tailwind styles, add themes, plugins, and specify the paths to your template files.
- **Key Sections**:
  - **`content`**: Specifies the files Tailwind should scan for class names.
  - **`theme`**: Extend or customize the default theme.
  - **`plugins`**: Add official or community plugins.

- **Example**:

  ```js
  // tailwind.config.js

  module.exports = {
    content: [
      "./app/**/*.{js,ts,jsx,tsx}",
      "./components/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
      extend: {
        colors: {
          primary: '#1DA1F2',
        },
      },
    },
    plugins: [],
  };
  ```

#### **3. The `app` Directory**

- **Purpose**: The `app` directory is part of Next.js's **App Router** (introduced in Next.js 13), which provides a new way to structure your application.
- **Contents**:
  - **Pages**: Each file in the `app` directory represents a route.
  - **Layouts**: Shared layouts for nested routes.
  - **Components**: Reusable UI components.
  - **API Routes**: Handlers for backend API endpoints (if using the `/pages/api` directory in older versions).
- **Example Structure**:

  ```
  my-next-app/
  ├─ app/
  │  ├─ layout.tsx
  │  ├─ page.tsx
  │  ├─ about/
  │  │  └─ page.tsx
  │  └─ dashboard/
  │     ├─ layout.tsx
  │     └─ page.tsx
  ```
![](https://www.notion.so/image/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F085e8ad8-528e-47d7-8922-a23dc4016453%2Fbf0c63a2-c1e0-488d-82bb-8032ce792faa%2FScreenshot_2024-03-02_at_1.23.58_PM.png?table=block&id=8f7b4e4a-0360-4d4d-9079-fc6e66ff42a2&cache=v2)
---

### **Running the Project**

Start the development server to see your clean Next.js application.

```bash
npm run dev
```

- Open [http://localhost:3000](http://localhost:3000) in your browser to view the app.
- You should see a blank page, as we've removed the default content.

---

### **Next Steps**

Now that you have a minimal Next.js application set up with Tailwind CSS:

- **Add Components**: Start building your UI components inside the `app` directory.
- **Use Tailwind Classes**: Utilize Tailwind's utility classes to style your components.
- **Explore Routing**: Create new pages by adding files to the `app` directory.
- **Set Up API Routes** (if needed): For backend functionality, you can create API endpoints.

---

### **Additional Tips**

- **TypeScript Support**: If you didn't enable TypeScript during setup and wish to add it later, create a `tsconfig.json` file and run the development server. Next.js will automatically configure TypeScript for you.
- **Customizing Tailwind**: Use the `tailwind.config.js` file to customize themes, colors, spacing, etc.
- **Global Styles**: Keep any global CSS styles you need in `globals.css`, but consider using Tailwind classes whenever possible to keep styles consistent and maintainable.

---

### **Conclusion**

You've successfully bootstrapped a simple Next.js application integrated with Tailwind CSS and cleaned up the initial setup to start from scratch. You're now ready to build your application with a clean slate, leveraging the power of Next.js and the utility-first styling of Tailwind CSS.

---

### **Bootstrapping a Simple Next.js App with Tailwind CSS**

In this guide, we'll walk through the steps to create a basic Next.js application integrated with Tailwind CSS. We'll also explain the purpose of key configuration files and clean up the initial setup to start with a minimal template.

---

#### **Prerequisites**

- **Node.js**: Ensure you have Node.js installed (version 14.0 or higher is recommended).
- **Package Manager**: `npm` comes with Node.js, or you can use `yarn` if preferred.

---

### **Step 1: Create a New Next.js Project**

Use the `create-next-app` command to bootstrap a new Next.js application.

```bash
npx create-next-app@latest my-next-app
```

- **Replace** `my-next-app` with your desired project name.
- **Options**: During setup, you can opt-in for TypeScript support and other features as prompted.

---

### **Step 2: Navigate to Your Project Directory**

```bash
cd my-next-app
```

---

### **Step 3: Install Tailwind CSS**

We'll install Tailwind CSS and its peer dependencies.

```bash
npm install tailwindcss postcss autoprefixer
```

Initialize Tailwind by generating the configuration files.

```bash
npx tailwindcss init -p
```

This creates:

- **`tailwind.config.js`**: Tailwind CSS configuration file.
- **`postcss.config.js`**: PostCSS configuration file.

---

### **Step 4: Configure `tailwind.config.js`**

Update the `tailwind.config.js` file to specify the paths to all of your pages and components.

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{js,ts,jsx,tsx}", // Include all files in the 'app' directory
    "./components/**/*.{js,ts,jsx,tsx}", // Include all files in the 'components' directory if you have one
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

---

### **Step 5: Add Tailwind Directives to `globals.css`**

Locate the `globals.css` file in `app/globals.css` (or `styles/globals.css` depending on your Next.js version). Replace its content with Tailwind's base styles.

```css
/* app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* You can add custom global styles below */
```

---

### **Step 6: Clean Up the Initial Setup**

#### **a. Remove Default Content from `app/page.tsx`**

- **File Location**: `app/page.tsx` (for TypeScript projects) or `app/page.js` (for JavaScript projects).
- **Action**: Delete all the existing content within the component and return an empty `<div>`.

**Before:**

```tsx
// app/page.tsx

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      {/* Default content and components */}
    </main>
  );
}
```

**After:**

```tsx
// app/page.tsx

export default function Home() {
  return <div></div>;
}
```

#### **b. Clean Up `globals.css`**

- **Action**: Remove any default CSS styles provided by Next.js, but **keep the Tailwind directives** (`@tailwind base;`, `@tailwind components;`, `@tailwind utilities;`).

**Before:**

```css
/* app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen;
  /* ... other default styles ... */
}

/* ... other default styles ... */
```

**After:**

```css
/* app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* You can add custom global styles here if needed */
```

---

### **Understanding Key Configuration Files**

#### **1. `next.config.mjs`**

- **Purpose**: This is the Next.js configuration file where you can customize various settings of your Next.js application.
- **Common Configurations**:
  - Enabling experimental features.
  - Customizing webpack configuration.
  - Setting environment variables.
- **Example**:

  ```js
  // next.config.mjs

  const nextConfig = {
    reactStrictMode: true,
    swcMinify: true,
    // Additional configurations...
  };

  export default nextConfig;
  ```

#### **2. `tailwind.config.js`**

- **Purpose**: Tailwind CSS configuration file where you can customize the default Tailwind styles, add themes, plugins, and specify the paths to your template files.
- **Key Sections**:
  - **`content`**: Specifies the files Tailwind should scan for class names.
  - **`theme`**: Extend or customize the default theme.
  - **`plugins`**: Add official or community plugins.

- **Example**:

  ```js
  // tailwind.config.js

  module.exports = {
    content: [
      "./app/**/*.{js,ts,jsx,tsx}",
      "./components/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
      extend: {
        colors: {
          primary: '#1DA1F2',
        },
      },
    },
    plugins: [],
  };
  ```

#### **3. The `app` Directory**

- **Purpose**: The `app` directory is part of Next.js's **App Router** (introduced in Next.js 13), which provides a new way to structure your application.
- **Contents**:
  - **Pages**: Each file in the `app` directory represents a route.
  - **Layouts**: Shared layouts for nested routes.
  - **Components**: Reusable UI components.
  - **API Routes**: Handlers for backend API endpoints (if using the `/pages/api` directory in older versions).
- **Example Structure**:

  ```
  my-next-app/
  ├─ app/
  │  ├─ layout.tsx
  │  ├─ page.tsx
  │  ├─ about/
  │  │  └─ page.tsx
  │  └─ dashboard/
  │     ├─ layout.tsx
  │     └─ page.tsx
  ```

---

### **Running the Project**

Start the development server to see your clean Next.js application.

```bash
npm run dev
```

- Open [http://localhost:3000](http://localhost:3000) in your browser to view the app.
- You should see a blank page, as we've removed the default content.

---

### **Next Steps**

Now that you have a minimal Next.js application set up with Tailwind CSS:

- **Add Components**: Start building your UI components inside the `app` directory.
- **Use Tailwind Classes**: Utilize Tailwind's utility classes to style your components.
- **Explore Routing**: Create new pages by adding files to the `app` directory.
- **Set Up API Routes** (if needed): For backend functionality, you can create API endpoints.

---

### **Additional Tips**

- **TypeScript Support**: If you didn't enable TypeScript during setup and wish to add it later, create a `tsconfig.json` file and run the development server. Next.js will automatically configure TypeScript for you.
- **Customizing Tailwind**: Use the `tailwind.config.js` file to customize themes, colors, spacing, etc.
- **Global Styles**: Keep any global CSS styles you need in `globals.css`, but consider using Tailwind classes whenever possible to keep styles consistent and maintainable.

---

### **Conclusion**

You've successfully bootstrapped a simple Next.js application integrated with Tailwind CSS and cleaned up the initial setup to start from scratch. You're now ready to build your application with a clean slate, leveraging the power of Next.js and the utility-first styling of Tailwind CSS.

---

### **Understanding Routing in Next.js**

Next.js uses a **file-based routing** system, which means the structure of your files and folders within the `app` directory defines the routes (URLs) of your application. This approach simplifies routing by eliminating the need for a separate routing library, like `react-router-dom`, and leverages the filesystem to map routes directly.

---

#### **Basic Concepts of Next.js Routing**

- **Pages**: Each file inside the `app` directory (with specific exceptions) becomes a route.
  - For example, `app/page.tsx` corresponds to the `/` route (the homepage).
- **Nested Routes**: Folders within the `app` directory create nested routes.
  - For example, `app/signup/page.tsx` corresponds to the `/signup` route.
- **Dynamic Routes**: Files or folders with brackets `[ ]` create dynamic routes.
  - For example, `app/blog/[id]/page.tsx` corresponds to `/blog/123`, where `123` is a dynamic parameter.

---

### **Adding a New Route: The Signin Page**

#### **Step 1: Create the Route**

To add a `signin` route, you'll create a new folder and file within the `app` directory:

1. **Create a Folder**: `app/signin/`
2. **Create a Page File**: `app/signin/page.tsx` (if you're using TypeScript) or `page.js` (for JavaScript)

#### **Step 2: Implement the Signin Component**

In `app/signin/page.tsx`, you'll define the `Signin` component:

```tsx
// app/signin/page.tsx

export default function Signin() {
  return (
    <div>
      hi from the signin page
    </div>
  );
}
```

#### **Step 3: Start the Development Server**

Run the application:

```bash
npm run dev
```

- Open [http://localhost:3000/signin](http://localhost:3000/signin) to view the signin page.
- You should see "hi from the signin page" displayed.

---

### **Assignment: Prettify the Signin Page**

Now, let's replace the basic signin page with a more styled version using Tailwind CSS.

#### **Updated Signin Component**

```tsx
// app/signin/page.tsx

interface LabelledInputProps {
  label: string;
  placeholder: string;
  type?: string;
}

function LabelledInput({ label, placeholder, type }: LabelledInputProps) {
  return (
    <div>
      <label className="block mb-2 text-sm text-black font-semibold pt-4">
        {label}
      </label>
      <input
        type={type || "text"}
        className="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5"
        placeholder={placeholder}
        required
      />
    </div>
  );
}

export default function Signin() {
  return (
    <div className="h-screen flex justify-center items-center bg-gray-100">
      <div className="max-w-sm w-full p-6 bg-white border border-gray-200 rounded-lg shadow-lg">
        <div className="mb-6">
          <h2 className="text-3xl font-extrabold text-center">Sign in</h2>
        </div>
        <LabelledInput label="Username" placeholder="your-email@example.com" />
        <LabelledInput
          label="Password"
          type="password"
          placeholder="********"
        />
        <button
          type="button"
          className="mt-8 w-full text-white bg-blue-600 hover:bg-blue-700 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 mb-2"
        >
          Sign in
        </button>
      </div>
    </div>
  );
}
```

---

### **Explanation of the Signin Component**

#### **Component Structure**

- **Outer `div`**: A full-height container centered both vertically and horizontally.
  - Classes:
    - `h-screen`: Sets the height to fill the viewport.
    - `flex justify-center items-center`: Centers the content.
    - `bg-gray-100`: Applies a light gray background.

- **Card Container**: A styled box that holds the signin form.
  - Classes:
    - `max-w-sm w-full p-6`: Sets a maximum width and padding.
    - `bg-white border border-gray-200 rounded-lg shadow-lg`: Styles the card with a white background, border, rounded corners, and shadow.

#### **Header Section**

- **Title**: Displays "Sign in" prominently.
  - Classes:
    - `text-3xl font-extrabold text-center`: Large, bold text centered.

#### **Form Inputs**

- **`LabelledInput` Component**: Reusable input component for form fields.
  - Props:
    - `label`: The text label for the input.
    - `placeholder`: Placeholder text inside the input.
    - `type`: The input type (e.g., "text", "password").

- **Usage**:
  - **Username Field**:
    ```jsx
    <LabelledInput label="Username" placeholder="your-email@example.com" />
    ```
  - **Password Field**:
    ```jsx
    <LabelledInput
      label="Password"
      type="password"
      placeholder="********"
    />
    ```

- **Styling in `LabelledInput`**:
  - **Label**:
    - `block mb-2 text-sm text-black font-semibold pt-4`: Styles the label as a block element with margin and padding adjustments.
  - **Input**:
    - `bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5`: Styles the input field with background color, borders, text size, rounded corners, focus states, and padding.

#### **Signin Button**

- **Button Element**:
  ```jsx
  <button
    type="button"
    className="mt-8 w-full text-white bg-blue-600 hover:bg-blue-700 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 mb-2"
  >
    Sign in
  </button>
  ```
- **Classes Explained**:
  - `mt-8 w-full`: Adds top margin and makes the button full width.
  - `text-white`: White text color.
  - `bg-blue-600 hover:bg-blue-700`: Blue background color that darkens on hover.
  - `focus:ring-4 focus:ring-blue-300`: Adds a blue ring around the button when focused.
  - `font-medium rounded-lg text-sm`: Medium font weight, rounded corners, small text size.
  - `px-5 py-2.5`: Horizontal and vertical padding.
  - `mb-2`: Bottom margin.

---

### **Enhancing the User Interface**

#### **1. Centering the Card Vertically and Horizontally**

- **Classes Used**:
  - `h-screen`: Sets the height of the parent container to the full viewport height.
  - `flex justify-center items-center`: Centers child elements both horizontally and vertically.

#### **2. Improving Accessibility**

- **Labels**: Ensure that each input field has a corresponding `<label>` for accessibility.
- **Button**:
  - Use semantic `<button>` elements instead of `<a>` tags for actions.
  - Ensure `type` is set appropriately (e.g., `type="submit"` if inside a form).

#### **3. Consistent Styling with Tailwind CSS**

- **Color Scheme**: Use Tailwind's color palette for consistent colors (e.g., `bg-blue-600`).
- **Responsive Design**: Tailwind provides responsive utility classes to adjust styles at different screen sizes.

---

### **Creating the Signup Page**

Similarly, you can create a `signup` page with its own route:

1. **Create the Folder and File**:

   - `app/signup/page.tsx`

2. **Implement the Signup Component**:

   ```tsx
   // app/signup/page.tsx

   import React from 'react';

   interface LabelledInputProps {
     label: string;
     placeholder: string;
     type?: string;
   }

   function LabelledInput({ label, placeholder, type }: LabelledInputProps) {
     return (
       <div>
         <label className="block mb-2 text-sm text-black font-semibold pt-4">
           {label}
         </label>
         <input
           type={type || "text"}
           className="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5"
           placeholder={placeholder}
           required
         />
       </div>
     );
   }

   export default function Signup() {
     return (
       <div className="h-screen flex justify-center items-center bg-gray-100">
         <div className="max-w-sm w-full p-6 bg-white border border-gray-200 rounded-lg shadow-lg">
           <div className="mb-6">
             <h2 className="text-3xl font-extrabold text-center">Sign up</h2>
           </div>
           <LabelledInput label="Email" placeholder="your-email@example.com" />
           <LabelledInput
             label="Password"
             type="password"
             placeholder="********"
           />
           <LabelledInput
             label="Confirm Password"
             type="password"
             placeholder="********"
           />
           <button
             type="button"
             className="mt-8 w-full text-white bg-green-600 hover:bg-green-700 focus:ring-4 focus:ring-green-300 font-medium rounded-lg text-sm px-5 py-2.5 mb-2"
           >
             Sign up
           </button>
         </div>
       </div>
     );
   }
   ```

- **Explanation**:
  - The structure is similar to the signin page.
  - Adjusted labels and placeholders for signup (e.g., "Confirm Password").
  - Changed button color to differentiate from signin (e.g., `bg-green-600`).

---

### **Understanding Next.js Routing with the App Router**

- **`app` Directory**: Introduced in Next.js 13, the `app` directory uses the **App Router** for structuring applications.

- **Routing Rules**:
  - **Root Page**: `app/page.tsx` corresponds to `/`.
  - **Nested Routes**: `app/signin/page.tsx` corresponds to `/signin`.
  - **Dynamic Routes**: Files with square brackets (e.g., `[id].tsx`) represent dynamic segments.

- **Layouts**:
  - You can create `layout.tsx` files in directories to define shared layouts for nested pages.

---

### **Navigating Between Pages**

To allow users to navigate between the signin and signup pages:

#### **Add Links**

In the `Signin` component, add a link to the signup page:

```jsx
import Link from 'next/link';

export default function Signin() {
  // ... existing code ...

  return (
    // ... existing code ...
    <div className="text-center mt-4">
      <p className="text-sm">
        Don't have an account?{' '}
        <Link href="/signup" className="text-blue-600 hover:underline">
          Sign up
        </Link>
      </p>
    </div>
  );
}
```

Similarly, in the `Signup` component, add a link to the signin page.

#### **Using the `Link` Component**

- **`Link` Component**: Provided by Next.js for client-side navigation.
- **Usage**:
  ```jsx
  <Link href="/signin">Sign in</Link>
  ```
- **Benefits**:
  - Enables faster navigation without full page reloads.
  - Preserves application state.

---

### **Running the Application**

1. **Start the Development Server**:

   ```bash
   npm run dev
   ```

2. **Access the Routes**:

   - **Signin Page**: [http://localhost:3000/signin](http://localhost:3000/signin)
   - **Signup Page**: [http://localhost:3000/signup](http://localhost:3000/signup)

3. **Test Navigation**:

   - Use the links added to navigate between signin and signup pages.

---

### **Summary**

- **File-Based Routing**: Next.js maps files and folders in the `app` directory directly to routes.
- **Creating Routes**:
  - Add a folder inside `app` for each route (e.g., `signin`, `signup`).
  - Inside each folder, create a `page.tsx` or `page.js` file.
- **Styling with Tailwind CSS**:
  - Utilize utility classes for rapid and consistent styling.
  - Create reusable components like `LabelledInput` to simplify form creation.
- **Navigation**:
  - Use Next.js's `Link` component for client-side transitions between pages.

---

### **Next Steps**

- **Form Handling**:
  - Implement form submission handling using Next.js API routes or client-side logic.
- **Authentication**:
  - Integrate authentication mechanisms (e.g., using NextAuth.js or custom solutions).
- **Validation**:
  - Add form validation to improve user experience.
- **State Management**:
  - Use React hooks (`useState`, `useEffect`) to manage form state.
- **Responsive Design**:
  - Ensure the pages are responsive on different screen sizes.

---

### **Additional Resources**

- **Next.js Documentation on Routing**:
  - [Defining Routes](https://nextjs.org/docs/app/building-your-application/routing/defining-routes)
- **Tailwind CSS Documentation**:
  - [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- **Next.js Link Component**:
  - [Next.js Link](https://nextjs.org/docs/api-reference/next/link)

